// Create classes

// Base asset
class Asset{
    
    constructor(){

        this.UUID = '';

    }

    load(data){
        for(var i in data){
            if(this.hasOwnProperty(i)){
                this[i] = data[i];
            }
        }
        if(this.UUID === ''){this.generateUUID();}
        
        this.onLoaded();
    }

    generateUUID(){
        this.UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        });
    }

    clone(){
        var asset = new this.constructor();

        for(var i in this){
            var d = this[i];

            if(asset[i] !== undefined && asset[i] !== null && asset[i].constructor === Array){
                d = d.slice();
            }
            asset[i] = d;
        }
        asset.generateUUID();
		asset.onClone();
        return asset;
    }
    

    // Overwrite these
    onLoaded(){}
    onClone(){}
	onAdd(){}


    // Static methods

    // Searches the database by id if id field exists
    static get(id){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be identified because it doesn't have a library entry");
            return;
        }

        if(!new this().hasOwnProperty('id')){
            console.error('Error, object "'+this.className()+'" doesn\'t have an id field');
            return false;
        }

        var scan = DB[this.className()];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(asset.id === id){
                return asset;
            }
        }

		console.error("Search for ", id, "in", this.className(), "yielded no results");
        return false;
    }

    // Searches the library for one or more objects
    static search(obj){

        
        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be searched because it doesn't have a library entry");
            return [];
        }

        var scan = DB[this.className()];
        var out = [];
        for(var i=0; i<scan.length; ++i){
            var asset = scan[i];
            if(this.compare(obj, asset)){
                out.push(asset);
            }
        }
        return out;
    }
    
    // Compares a search query object to an asset
    static compare(obj, asset){
        for(var i in obj){
            if(!asset.hasOwnProperty(i) || asset[i] !== obj[i]){
                return false;
            }
        }
        return true;
    }

    // Inserts into the library
    static insert(data){

        if(!DB.hasOwnProperty(this.className())){
            console.error(this.className(), "cannot be inserted because it doesn't have a library entry");
            return;
        }

        var add = new this(data);
		var db = DB[this.className()];
        db.push(add);
		add.onAdd();
    }

    static className(){
        return new this().constructor.name;
    }


	static convertArray(input){
		var i, out = [];
		for(i=0; i<input.length; ++i){
			out.push(new this(input[i]));
		}
		return out;
    }

}

















// Character
class Character extends Asset{

    constructor(data){
        super();

        this.id = '';       		// used only for NPCs, use UUID for PC
		this.socket_id = '';		// Identifier for websocket
        this.name = '';
        this.description = '';
		this.image = '';

        this.is_pc = false;
        this.abilities = [];
		this.abilities_unlocked = [];		// IDs
        this.tags = ["c_penis"];
		this.pronouns = [];				// Needs to be exactly 3 entries or they will be autogenerated: he/him/his | she/her/her | etc
		this.race = Race.get('fox');
		this.body_tags = [];			// For RP texts, things like fuzzy, shiny, spotted etc
		this.affinity = Ability.Packages.offensive;
		


		// PC only essentially
		this.level = 1;
		this.unspent_points = 0;
		this.experience = 0;
		this.cash = 0;

		// Meta generated on save
		this.modified = Date.now();

        this.team = Character.TEAM_NPC;

        this.armorSet = new Armor();
		this.armor_unlocked = ["goldenThong", "goldenBikini"]; // IDs


        // Max stats
        this.max_armor = 25;	// Should prevent certain enemy abilities, but can't be healed reliably
        this.max_hp = 25;		// Can be healed
        this.max_mana = 10;     // this should be flat
		this.accuracy = 0;		// bonus percent chance to hit
		this.dodge = 0;			// bonus percent chance to dodge
		

        // Stats
        this.armor = 25;		// 
        this.hp = 25;			// 
        this.mana = 1;			// 
        this.effects = [];
		this.mana_ticks = 0;
		this.color = "#EFE";	// Color is set when the battle starts

		this.TICKRATE = 0.3;

		// Used for texts only
		this.size = 5;			// 0 = small, 5 = average, 10 = very big
		this.strength = 5;		// 0 = weak, 5 = average, 10 = very strong


		// used for NPCS
		this.aiChat = null;
		this.social = 50;		// Chance at each ability to talk

        this.load(data); 

        return this;
    }



	// Stats
		damage(type, amount, attacker){

			amount = Math.abs(amount);
			var text;

			var preArmor = this.armor;
			
			var takeDamage =  (type === EffectData.Types.damage || type == EffectData.Types.armorDamage || type === EffectData.Types.hpDamage);
			// Detrimental
			if(takeDamage){
				amount += this.getDmgTakenAdder(attacker);

				this.applyEffectEvent(EffectData.Triggers.takeDamage, [amount]);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamage, [amount]);
			}


			if(type === EffectData.Types.damage){
				
				this.armor -= amount;
				text = ":TNAME: loses "+amount+" armor.";
				if(this.armor < 0){
					text = ":TNAME: loses ";
					if(Math.abs(this.armor) != amount){
						text+= (amount+this.armor)+" armor and "+Math.abs(this.armor)+" HP.";
					}
					else{
						text+= Math.abs(this.armor)+" HP.";
					}
					this.hp += this.armor;
				}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:text}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.heal){
				this.hp += amount;
				if(this.hp > this.max_hp){amount -= this.hp-this.max_hp;}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: gains "+amount+" HP."}).convert(attacker, this));
			}
			else if(type === EffectData.Types.armorDamage){
				this.armor -= amount;
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: loses "+amount+" armor."}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.hpDamage){
				this.hp -= amount;
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: loses "+amount+" HP."}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.armorHeal){
				this.armor += amount;
				if(this.armor > this.max_armor){amount -= this.armor-this.max_armor;}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: gains "+amount+" armor."}).convert(attacker, this));
			}

			// Mana
			else if(type === EffectData.Types.manaDamage){
				this.mana -= amount;
				if(this.mana < 0){
					amount += this.mana;
					this.mana = 0;
				}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: loses "+amount+" mana."}).convert(attacker, this), true);
			}
			else if(type === EffectData.Types.manaHeal){
				this.mana += amount;
				if(this.mana > this.max_mana){
					amount -= this.armor-this.max_armor;
					this.mana = this.max_mana;
				}
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME: gains "+amount+" mana."}).convert(attacker, this));
			}
			
			if(preArmor > 0 && this.armor <= 0){
				Game.Battle.statusTexts.add(attacker, this, new Text({text:":TNAME:'s "+this.armorSet.name+" was torn off!"}).convert(attacker, this), true);
				createjs.Sound.play('cloth_rip');
			}

			// Constraints
			if(this.hp > this.max_hp){this.hp = this.max_hp;}
			else if(this.hp <= 0){
				text = new Text({text:":TNAME: surrenders"});
				Game.Battle.statusTexts.add(attacker, this, text.convert(attacker, this), true);
				this.hp = 0;
			}
			if(this.armor > this.max_armor){this.armor = this.max_armor;}
			else if(this.armor < 0){this.armor = 0;}
			if(this.mana > this.max_mana){this.mana = this.max_mana;}
			else if(this.mana < 0){this.mana = 0;}


			if(takeDamage){
				this.applyEffectEvent(EffectData.Triggers.takeDamageAfter, [amount]);
				attacker.applyEffectEvent(EffectData.Triggers.dealDamageAfter, [amount]);
			}
			
		}

		isDead(){
			return this.hp <= 0;
		}

		getDodgeFloat(){
			return (this.getStaticValuePoints(EffectData.Types.dodge)+this.dodge)/100;
		}

		getHitFloat(){
			return (this.getStaticValuePoints(EffectData.Types.hit)+this.accuracy)/100;
		}

		getDmgTakenAdder(){
			return this.getStaticValuePoints(EffectData.Types.damage_boost);
		}

		getIsStunned(){
			return this.getEffectsWithStaticValue(EffectData.Types.stun).length;
		}

		// Gets a static value from effects
		getStaticValuePoints(effectType){
			var out = 0;
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				out += fx.getStaticValue(effectType);
			}
			return out;
		}

		// Same as above but returns all effects with a specific static type
		getEffectsWithStaticValue(effectType){
			var out = [];
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.getStaticValueEffects(effectType).length){
					out.push(fx);
				}
			}
			return out;
		}

		// Gets characters currently taunting you or false
		getTaunting(){
			var out = [];
			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.getStaticValueEffects(EffectData.Types.taunt).length && out.indexOf(fx.getAttacker()) === -1){
					out.push(fx.getAttacker());
				}
			}
			return out;
		}


    
	//
	
	// Tags & RP
        // Returns all tags
        getTags(){
            var out = this.tags.slice();
            // Armor stripped
            if(this.armor <= 0){
                out.push('nude');
            }
            // Get armor tags
            else{
                out = out.concat(this.armorSet.tags);
            }
			out = out.concat(this.race.tags);

			for(var i =0; i<this.effects.length; ++i)
				out = out.concat(this.effects[i].tags);

            return out;
        }

		getGender(){

			var penis = this.hasAnyTag('c_penis'), vagina = this.hasAnyTag('c_vagina'), breasts = this.hasAnyTag('c_breasts');

			if(penis && !vagina && !breasts)
				return 'male';
			if(vagina && breasts && !penis)
				return 'female';
			if(vagina && breasts && penis)
				return 'herm';
			if(penis && breasts && !vagina)
				return 'dickgirl';
			if(!penis && !breasts && vagina)
				return 'cboy';
			
			return 'unknown';

		}

        // Check if any tag of array scan exists 
        hasAnyTag(scan){

			if(scan.constructor !== Array){
				scan = [scan];
			}

            var tags = this.getTags();

            for(var i=0; i<scan.length; ++i){
                if(~tags.indexOf(scan[i])){
                    return true;
                }
            }
            return false;
        }

		getRaceName(){
			return this.race.getName(this.hasAnyTag('c_breasts'));
		}

		// RP Text
		getLabel(type){
			
			type = type.toUpperCase();
			var synonyms = [];
			var pronouns = this.getPronouns();
			
			// Any order
			if(~[":VNAME:", ":TNAME:", ':TARGET:'].indexOf(type)){
				return '%t';
			}
			if(~[':ANAME:', ':ATTACKER:'].indexOf(type)){
				return '%a';
			}
			
			if(~[':ARACE:', ":VRACE:", ":TRACE:"].indexOf(type)){
				return escape(this.getRaceName());
			}

			if(~[':ABREASTS:', ":VBREASTS:", ":TBREASTS:"].indexOf(type)){
				synonyms = ["boobs", "breasts", "tits"];
				if(!this.hasAnyTag("c_breasts")){
					synonyms = ["chest", "torso"];
				}
			}
			if(~[':BUTT:', ':TBUTT:', ':ABUTT:', ':VBUTT:'].indexOf(type)){
				synonyms = ["butt", "hiney", "rump"];
			}

			if(~[':ACLOTHES:', ':VCLOTHES:', ':TCLOTHES:'].indexOf(type)){
				if(this.armorSet && this.armorSet.name){
					return this.armorSet.name.toLowerCase();
				}
				return clothes;
			}

			// No synonyms on its own, fall through
			if(~[':VCROTCHEX:',':ACROTCHEX:',':TCROTCHEX:'].indexOf(type)){
				type = ':CROTCH:';
				if(this.hasAnyTag('c_penis')){type = ':VPENIS:';}
				else if(this.hasAnyTag('c_vagina')){type = ':VVAG:';}
			}
			
			if(~[':APENIS:', ':VPENIS:', ':TPENIS:'].indexOf(type)){
				synonyms = ["penis", "dick", "member", "cock"];
				if(!this.hasAnyTag("c_penis")){
					type = ':CROTCH:';
				}
			}
			if(~[':AVAG:',':VVAG:',':TVAG:',':TVAGINA:',':VVAGINA:',':AVAGINA:'].indexOf(type)){
				synonyms = ["vagina", "pussy", "cunt"];
				if(!this.hasAnyTag("c_vagina")){
					type = ':CROTCH:';
				}
			}
			// Catchall for groins
			if(~[':CROTCH:', ':GROIN:', ':TCROTCH:', ':TGROIN:', ':ACROTCH:', ':AGROIN:'].indexOf(type)){
				synonyms = ["crotch", "groin"];
			}

			if(~[':ABTAG:',':VBTAG:',':TBTAG:'].indexOf(type)){
				synonyms = this.body_tags;
			}

			if(~[':AHE:',":VHE:",":THE:"].indexOf(type)){
				return pronouns[0];
			}
			if(~[':AHIM:', ":VHIM:", ":THIM:"].indexOf(type)){
				return pronouns[1];
			}
			if(~[':AHIS:',":VHIS:",":THIS:"].indexOf(type)){
				return pronouns[2]; 
			}
			
			if(!synonyms.length){
				return "";
			}

			return synonyms[Math.floor(Math.random()*synonyms.length)];

		}

		getPronouns(){
			if(!this.pronouns || this.pronouns.length !== 3){
				// Auto generate
				var out = ["he", "him", "his"];
				if(this.hasAnyTag("c_breasts")){
					if(this.hasAnyTag('c_vagina') && this.hasAnyTag('c_penis')){
						out = ["shi", "hir", "hir"];
					}
					out = ["she", "her", "her"];
				}

				return out;
			}
			return this.pronouns;
		}

		// Returns a (link?). Use this whenever getting text in a battle
		getName(){
			return '<span style="color:'+this.color+'">'+escape(this.name)+'</span>';
		}

		getImage(){
			if(!this.image)
				return this.race.default_icon;

			var image = this.image;

			if(this.image.substr(0,6) !== 'https:'){
				if(this.image.substr(0,5) === 'http:')
					image = 'https'+image.substr(4);
				else
					image = 'https://'+image;
			}
			return image;
		}


    //
	
	// Gear

		ownsArmor(id){
			if(~this.armor_unlocked.indexOf(id))
				return true;
			return false;
		}

		unlockArmor(id){
			if(this.ownsArmor(id))
				return true;
			if(!this.equipArmor(id))
				return false;
				
			this.armor_unlocked.push(id);
			this.save();
		}

		equipArmor(id, save){
			var armor = Armor.get(id);
			if(armor === false)
				return false;
			
			this.armorSet = armor;

			if(save)
				this.save();
			
			return true;
		}

	//

	// Abilities
		// Returns true if you have as many abilities as you can hold
		abilitiesFull(){
			var n = 0;
			for(var i =0; i<this.abilities.length; ++i){
				var ability = this.abilities[i];
				if(~Ability.DEFAULTS.indexOf(ability.id))
					continue;
				if(++n >= 8){
					return true;
				}
			}
			return false;
		}

        addAbility(id, save){

			if(this.abilitiesFull()){
				return false;
			}

			var ability = null;
            if(id.constructor === Ability)
				ability = id;
			else{
				ability = Ability.get(id).clone();
			}
			if(!ability){
                console.error("Ability not found", id);
                return false;
            }

			if(Ability.DEFAULTS.indexOf(id) === -1 && this.abilities_unlocked.indexOf(id) === -1 && ability.id){
				// Add to unlocks
				this.abilities_unlocked.push(ability.id);
				save = true;
			}

            if(!this.hasAbility(ability.id)){
            	ability.parent = this;
            	this.abilities.push(ability);
			}

			if(save){
				this.save();
			}
			return true;
        }

		addAbilities(ids){
			for(var i =0; i<ids.length; ++i)
				this.addAbility(ids[i]);
		}

		removeAbility(id){
			// Can't remove defaults
			if(~Ability.DEFAULTS.indexOf(id)){
				return false;
			}

			for(var i =0; i<this.abilities.length; ++i){
				if(this.abilities[i].id === id){
					this.abilities.splice(i, 1);
					this.save();
					return true;
				}
			}

			
			return false;
		}

        hasAbility(id){
            for(var i=0; i<this.abilities.length; ++i){
                if(this.abilities[i].id === id){
                    return true;
                }
            }
            return false;
        }

        getAbilityByUuid(uuid){
            for(var i = 0; i<this.abilities.length; ++i){
                if(this.abilities[i].UUID === uuid){
                    return this.abilities[i];
                }
            }
            return false;
        }

		// Checks an array of IDs
		hasOneAbility(arr){
			for(var i =0; i<arr.length; ++i){
				if(this.hasAbility(arr[i])){
					return true;
				}
			}
			return false;
		}

		getUnlockableAbilities(){
			var out = [];
			var generic = Ability.search({playable:true, affinity:Ability.Packages.generic})
				.concat(Ability.search({playable:true, affinity:this.affinity}));
			
			for(var i =0; i<generic.length; ++i){
				if(!this.hasAbility(generic[i].id)){
					out.push(generic[i]);
				}
			}
			return out;

		}

	//

	// Experience, leveling & money
		getFreePoints(){
			return this.unspent_points;
		}

		isMaxLevel(){
			if(!this.getUnlockableAbilities().length){
				return true;
			}
		}

		addExperience(amount){

			if(this.isMaxLevel()){
				return;
			}

			this.experience+=amount;
			Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained "+amount+" experience."}).convert(this, this));

			var gainedLevel = false;
			while(this.experience >= this.getMaxExperience() && this.getUnlockableAbilities()){
				++this.level;
				++this.unspent_points;

				// Add affinity perk
				if(this.affinity === Ability.Packages.defensive)
					++this.max_hp;
				if(this.affinity === Ability.Packages.offensive)
					++this.accuracy;
				if(this.affinity === Ability.Packages.support)
					++this.max_armor;
				

				gainedLevel = true;
				this.experience -= this.getMaxExperience();
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: gained a level! Welcome to level "+this.level+"!"}).convert(this, this));
			}

			if(this.isMaxLevel())
				this.experience = 0;
			
			if(gainedLevel)
				createjs.Sound.play('levelup');

			this.save();
		}

		getMaxExperience(){
			var out = this.level;
			if(out>5){
				out = 5;
			}
			return out;
		}

		addMoney(amount, save){
			if(amount < 0 && Math.abs(amount) > this.cash){
				return false;
			}

			if(amount > 0)
				Game.Battle.statusTexts.add(this, this, new Text({text:":TARGET: was rewarded "+amount+" Ð."}).convert(this, this), false, false, true);

			this.cash+= amount;
			if(save)
				this.save();
			return true;
		}



	// 



	// Effects
		removeEffect(uuid, silent){
			for(var i =0; i<this.effects.length; ++i){
				if(this.effects[i].UUID === uuid){
					var fx = this.effects[i];
					if(fx.fadeText && !silent){
						var text = new Text({text:fx.fadeText});
						Game.Battle.statusTexts.add(fx.getAttacker(), this, text.convert(fx.getAttacker(), fx.getVictim()), !fx.detrimental);
					}
					this.effects.splice(i, 1);
					return;
				}
			}
		}

		removeEffectsByIds(ids, silent){
			for(var i =0; i<this.effects.length && this.effects.length; ++i){
				if(~ids.indexOf(this.effects[i].id)){
					this.removeEffect(this.effects[i].UUID, silent);
					--i;
				}
			}
		}

		applyEffectEvent(evt, data){
			var fx = this.effects.slice();		// Makes sure effects get removed properly
			for(var i=0; i<fx.length; ++i){
				fx[i].on(evt, data);
			}
		}

		hasEffectByCaster(id, casterUUID){
			for(var i=0; i<this.effects.length; ++i){
				if(this.effects[i].id === id && this.effects[i]._attacker === casterUUID){
					return this.effects[i];
				}
			}
			return false;
		}

		dispel(beneficial, max){

			var all = this.effects.slice();
			for(var i =0; i<all.length && (max > 0 || max === -1); ++i){
				var fx = all[i];
				if(
					(all.beneficial && beneficial) ||
					(!all.beneficial && !beneficial)
				){
					this.removeEffect(fx.UUID, false);
					--max;
				}
			}

		}


    //
	
	// Event listeners
        onLoaded(){

			var clone = this.abilities.slice();

			// Import abilities
			this.abilities = [];
			for(var i =0; i<clone.length; ++i){

				if(clone[i].constructor === Ability)
					this.addAbility(clone[i].id);
				else if(clone[i].constructor === Object)
					this.addAbility(new Ability(clone[i], this));
				else
					this.addAbility(clone[i]);
					
			}

			// Add required abilities
			var add = Ability.DEFAULTS;
			for(i=0; i<add.length; ++i){
				this.addAbility(add[i]);
			}
			
			// Handle other classes

			if(this.race.constructor !== Race){
				if(this.race.constructor === Object)
					this.race = new Race(this.race);
				else
					this.race = Race.get(this.race);
			}

			if(this.armorSet.constructor !== Armor){
				if(this.armorSet.constructor === Object)
					this.armorSet = new Armor(this.armorSet);
				else
					this.armorSet = Armor.get(this.armorSet);
			}


			// Effects are present when loaded from netgame
			for(i=0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.constructor === Object)
					this.effects[i] = new Effect(this.effects[i]);
			}

			// Use species as a name if name is not defined
			if(!this.name){
				this.name = this.race.name_male;
			}

        }

		onAdd(){
			DB.sort("Character", "name");
		}

        onClone(){
            for(var i=0; i<this.abilities.length; ++i){
                this.abilities[i] = this.abilities[i].clone();
                this.abilities[i].parent = this;
            }
            this.armorSet = this.armorSet.clone();
        }

        onBattleStart(){
            this.mana = 0;
            this.hp = this.max_hp;
            this.armor = this.max_armor;
            this.effects = [];
			this.mana_ticks = 1;

			if(!this.is_pc){
				this.aiChat = new AIChat(this);
			}

			for(var i =0; i<this.abilities.length; ++i){
				this.abilities[i].onBattleStart();
			}
        }

		// A battle has been won
		onVictory(){
			this.addMoney(5);
			this.addExperience(1); // Saves
		}

        onTurnStart(){
			this.mana_ticks+=this.TICKRATE;
			if(this.mana_ticks > 5){
				this.mana_ticks = 5;
			}
			this.mana+= Math.floor(this.mana_ticks);
			if(this.mana > this.max_mana){
				this.mana = this.max_mana;
			}

			// This has to go before next
			this.applyEffectEvent(EffectData.Triggers.turnStart);

			for(var i=0; i<this.abilities.length; ++i){
				this.abilities[i].onTurnStart();
			}

			
        }

        onTurnEnd(){
            this.applyEffectEvent(EffectData.Triggers.turnEnd);
        }

	//
	
	// Export - Import can just use new Character
		export(){
			var out = {
				UUID : this.UUID,
				id : this.id,
				name : this.name,
				description : this.description,
				image : this.image,
				abilities : this.abilities.map(function(val){return val.id;}),
				tags : this.tags,
				pronouns : this.pronouns,
				race : this.race.id,
				body_tags : this.body_tags,
				armorSet : this.armorSet.id,
				max_armor : this.max_armor,
				max_hp : this.max_hp,
				max_mana : this.max_mana,
				modified : this.modified,
				affinity : this.affinity,
				experience : this.experience,
				unspent_points : this.unspent_points,
				level : this.level,
				abilities_unlocked : this.abilities_unlocked,
				cash : this.cash,
				armor_unlocked : this.armor_unlocked,
				team : this.team,
				is_pc : this.is_pc,
				size : this.size,
				strength : this.strength
			};
			return out;
		}

		/*
			Needed exports in subclasses:
			- Ability
			- Race
			- Effects
		*/
		// Netgame export for the host to send to all other players
		hostExportFull(){
			var out = this.export();
			delete out.id;
			
			out.socket_id = this.socket_id;
			out.abilities = this.abilities.map(function(val){
				return val.export();
			});
			out.race = this.race.export();
			out.armorSet = this.armorSet.export();
			out.effects = this.effects.map(function(val){return val.export();});
			out.mana_ticks = this.mana_ticks;
			out.armor = this.armor;
			out.hp = this.hp;
			out.mana = this.mana;
			out.color = this.color;
			
			return out;
		}


		// Puts to DB
		save(){
			// This is not the active player
			if(this !== Game.player)
				return;
			this.modified = Date.now();
			return IDB.put('characters', this.export());
		}

}
Character.TEAM_PC = 0;
Character.TEAM_NPC = 1;
Character.TEAM_FFA = 2;

    



// Armor set
class Armor extends Asset{

    constructor(data){
        super();

        this.id = '';
        this.name = '';
        this.description = '';
        this.tags = [];
		this.in_store = true;

        this.load(data); 

        return this;
    }

	export(){
		return {
			id : this.id,
			name : this.name,
			description : this.description,
			tags : this.tags,
			in_store : this.in_store
		};
	}

    onClone(){

    }

}







// Abilities
class Ability extends Asset{



    constructor(data, parent){
        super();

        this.parent = parent;
        this.id = '';   // Should be unique
        this.name = '';
        this.description = '';
        this.manacost = 1;
        this.conditions = [];
        this.effects = [];				// [[Effect, stacks]...] || [Effect...]
        this.cooldown = 1;
		this.detrimental = true;
		this.ai_tags = [];				// Tags for AI, ex healing
		this.allow_dead = false;		// Usable on dead
		this.affinity = Ability.Packages.generic;
		this.playable = false;		
		this.icon = '';					// Should be an SVG	

        // Gameplay values
        this._cooldown = 0;
		
        this.load(data); 

        return this;
    }

	// Netgame export
	export(){


		return {
			UUID : this.UUID,
			id : this.id,
			name : this.name,
			description : this.description,
			manacost : this.manacost,
			conditions : this.conditions.map(function(val){ return val.export(); }),
			effects : this.effects.map(function(val){
				if(val.constructor !== Array){
					val = [val, 1];
				}
				val = val.slice();
				val[0] = val[0].export();
				return val;
			}),
			cooldown : this.cooldown,
			detrimental : this.detrimental,
			ai_tags : this.ai_tags.slice(),
			allow_dead : this.allow_dead,
			affinity : this.affinity,
			playable : this.playable,
			icon : this.icon,
			_cooldown : this._cooldown
		};
	}

	onLoaded(){
		var i;
		
		for(i=0; i<this.effects.length; ++i){
			var val = this.effects[i];
			if(val.constructor !== Array){
				val = [val, 1];
			}
			val[0] = new Effect(val[0]);
		}
		
		for(i=0; i<this.conditions.length; ++i){
			this.conditions[i] = new Condition(this.conditions[i]);
		}
	}


    // Returns an array of viable players for this spell or false if none
    usableOn(targ, verbose, allowError){
        if(targ.constructor !== Array){
            targ = [targ];
        }

        var out = [], i;

        if(this.parent.hp <= 0){ 
			if(allowError)
				Jasmop.Errors.addErrors('Invalid target');
			
			if(verbose){console.log(this.name, "fail because HP");} 
			return false; 
		}
        if(this.parent.mana < this.getManaCost()){ 
			
			if(allowError)
				Jasmop.Errors.addErrors('Insufficient mana');

			if(verbose){console.log(this.name, "fail because mana", this.parent);} 
			return false;
		}
        if(this._cooldown){ 

			if(allowError)
				Jasmop.Errors.addErrors('That ability is not ready yet');

			if(verbose){console.log(this.name, "fail because Cooldown");} 
			return false; 
		}
		if(this.parent.getIsStunned()){

			if(allowError)
				Jasmop.Errors.addErrors('You are incapacitated');

			if(verbose){console.log(this.name, "fail because stun");} 
			return false; 
		}
        
		// Manage taunt
		var taunts = this.parent.getTaunting(), t = [];

		// Calculate taunts. Should not work against buffs.
		if(taunts.length && this.detrimental){
			t = [];
			for(i = 0; i<taunts.length; ++i){
				if(~targ.indexOf(taunts[i])){
					t.push(taunts[i]);
				}
			}
			targ = t;
		}

		if(verbose)
			console.log("Scanning", this.name, "against", targ.length, "players");
        
		for(var x =0; x<targ.length; ++x){

            t = targ[x];

			if(t.isDead() && !this.allow_dead)
				continue;

			var success = true;
            for(i=0; i<this.conditions.length && success; ++i){

                var cond = this.conditions[i];
                if(!cond.validate(this.parent, t)){
					if(verbose){
						console.log(this.name, "fail because condition", cond, 'against', t.name);
					}
                    success = false;
                }
            }

            // At least one targ was accepted
            if(success){
				if(verbose){
					console.log(this.name, "Success against", t.name);
				}
                out.push(t);
            }


        }

        if(!out.length){
            return false;
        }
        return out;
    }

	// Returns true/false whether it hit or not
    useAgainst(targ, verbose){
        if(!this.usableOn(targ, verbose)){return false;}
        
		// Dodge, invul etc
		var fail = false;

		// Check dodge
		if(this.detrimental){

			var d = targ.getDodgeFloat()-this.parent.getHitFloat();
			if(Math.random() < targ.getDodgeFloat()-this.parent.getHitFloat()){
				fail = true;
			}
		}


		// Add effects
		if(!fail){

			for(var i =0; i<this.effects.length; ++i){
				var fx = this.effects[i];
				if(fx.constructor !== Array){fx = [fx];}

				fx[0].useAgainst( this.parent, targ, (fx[1] || 1) );
			}

			// Hit visual
			var visual = (this.detrimental ? 'hitDetrimental' : 'hitBeneficial');
			$("div.character[data-uuid="+targ.UUID+"]").toggleClass("hitDetrimental hitBeneficial", false);


			setTimeout(function(){
				$("div.character[data-uuid="+targ.UUID+"]").toggleClass(visual, true);
			}, 10);

		}

		// Run the original effects before raising this event
		if(this.detrimental){
			targ.applyEffectEvent(EffectData.Triggers.attacked);
		}

        // Consume mana
        this.parent.mana -= this.manacost;
		// Add cooldown
		this._cooldown = this.cooldown;
		return !fail;
    }

    // Events
    onClone(){
        this._cooldown = 0;
        var fx = [], i;

        for(i=0; i<this.effects.length; ++i){
			// effects can be either arrays or single objects, this converts all of them into arrays
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
			var arr = this.effects[i].slice();
			arr[0] = arr[0].clone();
            fx.push(arr);
        }
        this.effects = fx;
        fx = [];
        for(i=0; i<this.conditions.length; ++i){
            fx.push(this.conditions[i].clone());
        }
        this.conditions = fx;
    }

    onTurnStart(){
        --this._cooldown;
        if(this._cooldown < 0){
            this._cooldown = 0;
        }
    }

	onBattleStart(){
		this._cooldown = 0;
	}

	getManaCost(){
		// You might wanna check if this is a punishment before returning any custom val here. Otherwise punishments will fail because mana
		return this.manacost;
	}

	getButton(highlight){
		var out = '<div class="ability button '+(highlight ? ' highlighted ' : '')+'" data-uuid="'+this.UUID+'" data-id="'+Jasmop.Tools.htmlspecialchars(this.id)+'">';
				
			// Main presentation
			if(this.icon){
				out+= '<img class="icon" src="media/effects/'+this.icon+'" />';
			}

			out+= Jasmop.Tools.htmlspecialchars(this.name);
			out+= '<span class="cooldown"></span>';

			// Tooltip
			out+= 
				'<span class="tooltip info">'+Jasmop.Tools.htmlspecialchars(this.description)+
				'<br />Mana: '+(+this.getManaCost())+(this.cooldown > 1 ? ' CD: '+this.cooldown+' turns' : '')+'</span>';

		out+= '</div>';

		return out;
	}
}

Ability.Packages = {
	generic : 'GENERIC',
	offensive : 'OFFENSIVE',
	defensive : 'DEFENSIVE',
	support : 'SUPPORT'
};


// Effects
class Effect extends Asset{



    constructor(data){
        super();

		this.id = '';
		this.max_stacks = 1;
        this.duration = 0;
        this.detrimental = true;
        this.events = [];						// EffectData
		this.fadeText = "";
		this.applyText = "";
		this.target = Game.Consts.TARG_VICTIM;
		this.icon = '';
		this.tags = [];							// Custom tags to apply to the victim

		this.name = '';
		this.description = '';

        this._duration = 0;
        this._attacker = null;
        this._victim = null;
		this._stacks = 1;
        

        this.load(data); 

        return this;
    }

	// Netgame export
	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			max_stacks : this.max_stacks,
			duration : this.duration,
			detrimental : this.detrimental,
			events : this.events.map(function(val){return val.export();}),
			fadeText : this.fadeText,
			applyText : this.applyText,
			target : this.target,
			icon : this.icon,
			tags : this.tags.slice(),
			name : this.name,
			description : this.description,
			_duration : this._duration,
			_attacker : this._attacker,
			_victim : this._victim,
			_stacks : this._stacks
		};
	}

	getVictim(){return Netcode.getCharacterByUuid(this._victim);}
	getAttacker(){return Netcode.getCharacterByUuid(this._attacker);}

	onLoaded(){
		
		for(var i =0; i<this.events.length; ++i)
			this.events[i] = new EffectData(this.events[i]);
	}


	// Generic
    useAgainst(attacker, victim, stacks){

		if(victim.isDead()){
			return false;
		}

		// Creates a specific clone of this
        var clone = this.clone();
        clone._attacker = attacker.UUID;
        clone._victim = victim.UUID;

		// A self cast
		if(this.target === Game.Consts.TARG_ATTACKER){
			clone._victim = attacker.UUID;
		}

        clone._duration = this.duration;
		clone._stacks = stacks || 1;
		
        // Long term effect
        if(clone.duration){

			// See if effect exists by the caster, in that case, grab stacks from it
			var fx = clone.getVictim().hasEffectByCaster(this.id, clone._attacker);
			if(fx){
				clone._stacks += fx._stacks;
				clone.getVictim().removeEffectsByIds(this.id, true); // Silently remove the old effect
			}

          	clone.getVictim().effects.push(clone);
        }

		// Make sure stacks don't overflow
		if(clone._stacks > clone.max_stacks){
			clone._stacks = clone.max_stacks;
		}
		
		if(this.applyText){
			var text = new Text({text:this.applyText});
			Game.Battle.statusTexts.add(clone.getAttacker(), clone.getVictim(), text.convert(clone.getVictim(), clone.getVictim()), this.detrimental);
		}

		clone.on('apply');
		if(!clone.duration){
			clone.on('remove');
		}

    }

	// Specific
	remove(triggerer){

		// Removes from victim
		this.on("remove", triggerer);

		this.victim.removeEffect(this.UUID);

	}

	// Returns HTML with icon and info
	getIcon(){
		// no icon
		if(!this.icon)
			return '';

		var desc = new Text({text:Jasmop.Tools.htmlspecialchars(this.description)});

		var out = '<div class="spellIcon '+(this.detrimental ? 'detrimental' : '')+'">';
			out+= '<div class="icon"><img src="media/effects/'+this.icon+'" /></div>';
			out+= '<div class="turns">'+this._duration+'</div>';
			out+= '<span class="tooltip">'+this.name+(this._stacks > 1 ? ' x'+this.stacks : '')+(this._duration ? ' ('+this._duration+' Turns)' : '')+'<br />'+
				desc.convert(this.getAttacker(), this.getVictim()).split('%a').join(this.getAttacker().getName())+
			'</span>';
		out+= '</div>';

		return out;
	}

	// Generic event listener
    on(evtName, triggerer, data){

		for(var i =0; i<this.events.length; ++i){
			var evt = this.events[i];
			if(evt.hasTrigger(evtName, data)){
				this.runEvt(evt);
			}
		}


		// Using _victim and _attacker directly is fine here because of string UUID comparison
		if(
			// Self effects tick on turn start
			(evtName === EffectData.Triggers.turnStart && this._attacker === this._victim) ||
			// Other player effects tick on turn end
			(evtName === EffectData.Triggers.turnEnd && this._attacker !== this._victim)
		){
			--this._duration;
			if(this._duration <= 0){
				this.getVictim().removeEffect(this.UUID);
			}
		}

    }

	// Runs an event
	runEvt(evt, triggerer, data){

		var fxs = evt.effects.slice();
		var attacker = this.getAttacker();
		var victim = this.getVictim();

		if(fxs.target === Game.Consts.TARG_ATTACKER){
			attacker = this.getVictim();
			victim = this.getAttacker();
		}

		for(var i=0; i<fxs.length; ++i){



			var fx = fxs[i];
			if(fx.constructor !== Array){fx = [fx];}
			else{ fx = fx.slice(); }

			var type = fx[0].toLowerCase();
			fx.splice(0,1);

			// Standard damage types
			if(
				type === EffectData.Types.damage ||
				type === EffectData.Types.heal ||
				type === EffectData.Types.armorDamage ||
				type === EffectData.Types.hpDamage ||
				type === EffectData.Types.armorHeal ||
				type === EffectData.Types.manaHeal ||
				type === EffectData.Types.manaDamage				
			){
				victim.damage(type, fx.shift(), attacker);
			}

			if(type === EffectData.Types.remByID){
				victim.removeEffectsByIds(fx);
			}
			if(type === EffectData.Types.remThis){
				victim.removeEffect(this.UUID);
			}

			if(type === EffectData.Types.dispel){
				var ben = fx[0] || false;
				var max = fx[1] !== undefined ? +fx[1] : -1;
				victim.dispel(ben, max);
			}
			
		}


	}

	// Gets a flat value such as dodge
	getStaticValue(type){
		var out = 0;
		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			out+= fxs[i].getStaticValue(type);
		}
		return out;
	}

	// Checks if a flat value such as taunt exists, and returns those values
	getStaticValueEffects(type){
		var out = [];
		var fxs = this.events;
		for(var i=0; i<fxs.length; ++i){
			if(fxs[i].hasStaticValue(type))
				out.push(fxs[i]);
		}
		return out;
	}

}

class EffectData extends Asset{

    constructor(data){
        super();

        // Types are case insensitive
        this.triggers = [];         // [[type, arg1, arg2...]...] || [type...]
        this.effects = [];          // [[type, arg1, arg2...]...] || [type...]
		this.target = Game.Consts.TARG_VICTIM;

        this.load(data);
    }

	export(){
		return {
			triggers : this.triggers.slice(),
			effects : this.effects.slice(),
			target : this.target
		};
	}

	onLoaded(){
		for(var i =0; i<this.effects.length; ++i){
			if(this.effects[i].constructor !== Array){
				this.effects[i] = [this.effects[i]];
			}
		}
	}

	hasTrigger(evtName, data){

		evtName = evtName.toLowerCase();
		var triggers = this.triggers.slice();
		var effects = this.effects.slice();

		for(var i =0; i<triggers.length; ++i){
			var tr = triggers[i];
			if(tr === undefined){
				console.error("Invalid trigger in effectData", this);
			}

			if(tr.constructor !== Array){
				tr = [tr];
			}

			tr = tr.slice(); // Copies the array

			var type = tr[0];
			tr.splice(0,1);		// Tr is now args

			if(type === evtName){

				// Todo: Validate tr against data
				return true;

			}

		}

		return false;
	}

	// get a static value such as dodge. Obviously does not work when this has a trigger
	getStaticValue(type){
		if(this.triggers.length){return 0;}
		var out = 0;
		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];
			if(fx.length < 2 || isNaN(fx[1]) || fx[0] !== type){continue;} // Static values should have at least 1 parameter
			out+= fx[1];
		}
		return out;
	}

	// Checks if a static value exists in this effect
	hasStaticValue(type){
		if(this.triggers.length){return false;}

		for(var i =0; i<this.effects.length; ++i){
			var fx = this.effects[i];
			if(fx[0] === type){
				return true;
			}
		}
		return false;
	}

}

// A list of possible triggers. Case insensitive
EffectData.Triggers = {
    apply : 'apply',    // Raised when the effect is added
    turnStart : "turnstart",			// Raised on turn start
    turnEnd : "turnend",				// Raised on turn end 
    takeDamage : "takedamage",			// *Raised before you take any damage
    dealDamage : "dealdamage",			// *Raised before you successfully deal damage
	takeDamageAfter : "takedamageafter",			// *Raised after you take any damage
    dealDamageAfter : "dealdamageafter",			// *Raised after you successfully deal damage
	attacked : "attacked",				// Raised when receiving an attack, no matter if it hit or not
};

EffectData.Types = {
    damage : "dmg",                     // (int)points - Straight up damage
    heal : "heal",                      // (int)points - HP healing
    armorDamage : "ardmg",              // (int)points - Damage only armor
	hpDamage : "hpdmg",              	// (int)points - Damage only hp
	armorHeal : "arheal",              	// (int)points - Heal only armor
	dodge : "dodge",					// (int)percent - Grants a chance to dodge a detrimental effect
	remByID : "rembyid",				// (str)id1, id2... - Removes an effect by ID
	remThis : "remthis",				// void - Removes this effect
	hit : "hit",						// (int)percent - Increases or decreases hit chance
	damage_boost : "dmgboost",			// (int)dmg - Whenever target takes damage, this amount of point is added
	taunt : "taunt",					// void - Characters affected by taunt can only target the characters that taunted
	stun : "stun",						// void - Prevents character from taking action
	dispel : "dispel",					// (bool)beneficial = false, (int)max = -1 - Removes one or more effects
	manaDamage : "manadmg",				// (int)points - Remove mana
	manaHeal : "manaheal",				// (int)points - Add mana
	

};



// Conditions
// This class expects arguments when instantiated
class Condition extends Asset{

	constructor(data){
		
		super();

		this.type = "SELF";
		this.data = [];
		this.target = Game.Consts.TARG_VICTIM;     // If this is Game.TARG_ATTACKER, validate will validate
		this.inverse = false;

		this.load(data);
		return this;
	}

	export(){
		return {
			type : this.type,
			data : this.data.slice(),
			target : this.target,
			inverse : this.inverse
		};
	}

	onLoaded(){
		this.type = this.type.toUpperCase();
	}

	// Validates all
	validate(attacker, victim, ability, success, verbose){

		var a = attacker, b = victim;
		if(this.target === Game.Consts.TARG_ATTACKER){
			// Reverse
			a = victim;
			b = attacker;
		}

		var att = this.pvtValidate(a, b, ability, success);
		if(this.inverse)
			att = !att;

		if(att !== true){
			if(verbose){
				console.log(this.type, this.data, "failed", a, b, ability, success);
			}
			return false;
		}


		return true;
	}

	// Validates a single condition
	pvtValidate(attacker, victim, ability, success){

		// Compare both
		if(this.type === Condition.FRIEND && attacker.team !== victim.team){
			return false;
		}
		if(this.type === Condition.ENEMY && attacker.team === victim.team){
			return false;
		}
		if(this.type === Condition.SELF && attacker.UUID !== victim.UUID){
			return false;
		}
		
		if(this.type === Condition.STRONGER_THAN && attacker.strength < victim.strength)
			return false;
		if(this.type === Condition.WEAKER_THAN && attacker.strength > victim.strength)
			return false;
		if(this.type === Condition.LARGER_THAN && attacker.size < victim.size)
			return false;
		if(this.type === Condition.SMALLER_THAN && attacker.size > victim.size)
			return false;
		

		if(this.type === Condition.RACE && this.data.indexOf(victim.race.id) === -1){return false;}
		if(this.type === Condition.HUMANOID && !victim.race.humanoid){return false;}
		if(this.type === Condition.BEAST && victim.race.humanoid){return false;}
		

		// Check only victim
		if(this.type === Condition.TAGS && !victim.hasAnyTag(this.data))return false;
		if(this.type === Condition.NOT_TAGS && victim.hasAnyTag(this.data)){return false;}


		// Text conditions only
		if(this.type === Condition.ABILITY && (!ability || this.data.indexOf(ability.id) === -1)){ return false; }
		if(this.type === Condition.MISS && success){ return false; }
		

		if(this.type === Condition.MANA_GREATER_THAN && victim.mana <= this.data[0])
			return false;

		return true;

	}

}

// For naked, use Condition.TAGS ["nude"]
Condition.SELF = "SELF";            		// void - Victim is attacker
Condition.FRIEND = "FRIEND";        		// void - Victim is same team as attacker
Condition.ENEMY = "ENEMY";          		// void - Victim is not same team as attacker
Condition.TAGS = "TAGS";            		// (str)tag1, (str)tag2... -  Has ANY of these tags
Condition.ABILITY = "ABILITY";				// [abilityid, abilityid...] - text condition only 
Condition.MISS = "MISS";					// void - text condition only - validates if an ability failed 
Condition.NOT_TAGS = "NOT_TAGS";			// tag1, tag2... - Has NONE of these tags
Condition.RACE = "RACE";					// id1, id2... - Race is ANY of these. Uses id
Condition.HUMANOID = "HUMANOID";			// void - Target is a humanoid
Condition.BEAST = "BEAST";					// void - Target is a beast
Condition.STRONGER_THAN = "STRONGER";		// void - Attacker is stronger than target
Condition.WEAKER_THAN = "WEAKER";			// void - Attacker is weaker than target
Condition.LARGER_THAN = "LARGER";			// void - Attacker is larger than target
Condition.SMALLER_THAN = "SMALLER";			// void - Attacker is smaller than target
Condition.MANA_GREATER_THAN = "MGT";		// (int)amount - Mana is greater than this value




// Texts
// This class expects arguments when instantiated
class Text extends Asset{

	constructor(data){
		super();
		this.ait = [];			// AI-tags
		this.conditions = [];
		this.text = "";
		this.sound = "";
		this.debug = false;		// Enables debugging
		this.load(data);
		return this;
	}

	// Validate the conditions
	validate(attacker, victim, ability, success, verbose){
		
		// Check if miss exists, if not, and this is a fail, then return false
		var hasMiss = false;

		for(var i=0; i<this.conditions.length; ++i){
			if(this.conditions[i] === undefined || this.conditions[i].constructor !== Condition)
				console.error("Undefined or invalid type condition in ", this);
			if(this.conditions[i].type === Condition.MISS){hasMiss = true;}
			if(!this.conditions[i].validate(attacker, victim, ability, success, verbose)){
				return false;
			}
		}
		if(!hasMiss && !success){
			return false;
		}
		return true;
	}

	// Converts tags
	convert(attacker, victim, ability){

		var spl = this.text.split(/(:.*?:)/gi);
		var out = [];
		for(var i=0; i<spl.length; ++i){
			if(i%2 != 1){
				out.push(spl[i]);
				continue;
			}
			var short = spl[i].toLowerCase();

			// Special case non-player tags
			if(short === ':abil:'){
				short = ability.name;
			}
			else if(short.charAt(1) === "a"){

				if(!attacker){
					console.error("Trying to convert :A*: label with no attacker defined. Text was ", short);
				}
				// Target attacker
				short = attacker.getLabel(short);
			}
			else{
				// Target attacker
				short = victim.getLabel(short);
			}
			

			out.push(short);
		}

		return out.join('');

	}

	// Fetches a text
	static generate(attacker, victim, ability, success){
		

		var all = DB.Text;
		var allowed = [];

		var verb = false; //ability && ability.id === 'LOW_BLOW';

		for(var i =0; i<all.length; ++i){

			
			if(all[i].validate(attacker, victim, ability, success, verb || all[i].debug)){
				allowed.push(all[i]);
			}

		}
		if(!allowed.length){
			if(success){

				if(attacker === victim)
					allowed = [new Text({text:":ANAME: used :ABIL:."})];
				else
					allowed = [new Text({text:":ANAME: used :ABIL: on :TNAME:."})];
				
			}
			else
				allowed = [new Text({text:":ANAME: tried to use :ABIL: on :TNAME:, but failed!", sound:'fail'})];
			
		}
		
		if(verb){
			console.log("Allowed texts", allowed);
		}
		var text = allowed[Math.floor(Math.random()*allowed.length)];

		
		return text;
	}

	onAdd(){
		var pos = this.ait.indexOf(undefined);
		if(~pos){
			console.error("Undefined AIT in text", this.text, "entry", this.ait);
		}
	}

}

// Widely supported AI tags, modders can write their own obviously
Text.AIT = {
	
	// zone of attack
	aBreasts : 'aBreasts',
	aButt : 'aButt',
	aBody : 'aBody',
	aGroin : 'aGroin',
	aPenis : 'aPenis',
	aVag : 'aVag',
	aMouth : 'aMouth',
	aForeskin : 'aForeskin',
	aTentacle : 'aTentacle',		// A tentacle was involved

	aCloth : 'aCloth',			// Can be combined with above, when attacking clothing specific



	// type of attack
	tSlap : 'tSlap',
	tPunch : 'tPunch',
	tKick : 'tKick',
	tTwist : 'tTwist',
	tTickle : 'tTickle',
	tLick : 'tLick',
	tTug : 'tTug',
	tRub : 'tRub',
	tPin : 'tPin',			// Attacker's penis thrust into zone
	tTwang : 'tTwang',		// Singshotted clothing
	tBite : 'tBite',
	tPinch : 'tPinch',
	tSqueeze : 'tSqueeze',
	tScratch :'tScratch',			// Scratching,. not clawing
	tFacial : 'tFacial',					// Cumming on face
	tCumInside : 'tCumInside',				// Cumming inside
	tCold : 'tCold',						// Cold effects
	tWet : 'tWet',							// A wet attack
	tPen : 'tPen',							// Penetrative, but not with a penis
	tExpose : 'tExpose',					// Expose a player through their clothes


};

/**
 * Text replacers:
 * replace x with A or V/T for attacker or victim/target
 * :xNAME: - Name
 * :xRACE: - Species
 * :xBREASTS: - Breasts, based on breast setting. If no breasts, returns a synonym for breasts.
 * :BUTT: - Synonym for butt
 * :xPENIS: - Penis, based on settings. If not present, returns the same as :CROTCH:
 * :xVAG: - Vagina, based on settings. If not present, returns the same as :CROTCH:
 * :xCROTCHEX: - Vagina, penis, or crotch based on the setting
 * :CROTCH: - Crotch, groin, etc
 * :xBTAG: - Random body part based on the character's bodytags
 * :xHE: - he/she / Custom pronoun
 * :xHIM: - him/her / Custom pronoun
 * :xHIS: - his/her / Custom pronoun
 * :ABIL: - Ability name
 * :xCLOTHES: - Clothing name or "clothes" if not set

 */



class Race extends Asset{

	constructor(data){
		super();
		
		this.id = '';
		this.name_male = "";
		this.name_female = "";		// if not set, name_male will be used instead
		this.description = "";
		this.tags = [];
		this.humanoid = true;
		this.playable = true;
		this.default_icon = '';

		this.load(data);
		return this;
	}

	export(){
		return {
			UUID : this.UUID,
			id : this.id,
			name_male : this.name_male,
			name_female : this.name_female,
			description : this.description,
			tags : this.tags,
			humanoid : this.humanoid,
			playable : this.playable,
			default_icon : this.default_icon
		};
	}

	getName(isFemale){

		if(isFemale && this.name_female){
			return this.name_female;
		}

		return this.name_male;

	}

	onLoaded(){

	}

	// This has been inserted into the database
	onAdd(){
		DB.sort("Race", "name_male");
	}

}


